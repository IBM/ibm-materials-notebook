import { IToken } from "chevrotain";
import { CmdlToken } from "./cmdl-ast";
import { parserInstance } from "./parser";
import {
  GroupCstChildren,
  GroupDeclarationCstChildren,
  GroupItemCstChildren,
  ImportStatementCstChildren,
  NumericalValueCstChildren,
  PropertyItemCstChildren,
  StatementCstChildren,
  UncertaintyExpressionCstChildren,
  ValueCstChildren,
  ListCstChildren,
  RecordCstChildren,
  ReferenceDeclarationCstChildren,
  NamedGroupCstChildren,
  RefListCstChildren,
  ArrowPropertyCstChildren,
  ReferencePipeCstChildren,
  VariableGroupCstChildren,
  AliasClauseCstChildren,
  ImportFileStatementCstChildren,
  AssignmentPropertyCstChildren,
} from "./parser-types";
import {
  ImportOp,
  GeneralGroup,
  Group,
  CmdlTree,
  NamedGroup,
  ReferenceGroup,
  VariableGroup,
  ListProperty,
  BoolProperty,
  NumericalProperty,
  RefListProperty,
  RefProperty,
  StringProperty,
  VariableProperty,
  AngleProperty,
  ImportFileOp,
  AssignmentProperty,
} from "./cmdl-tree";

const BaseVisitor = parserInstance.getBaseCstVisitorConstructor();

/**
 * Class to traverse CST generated by Chevrotain parser and compile an AST representation as a CMDL tree
 */
export class CstRecordVisitor extends BaseVisitor {
  constructor() {
    super();
    this.validateVisitor();
  }

  /**
   * Constructs root node for CMDL
   * @param ctx RecordCstChildren
   * @returns CMDLtree
   */
  public record(ctx: RecordCstChildren): CmdlTree {
    const rootNode = new CmdlTree();

    if (!ctx.statement) {
      return rootNode;
    }

    for (const statement of ctx.statement) {
      this.visit(statement, rootNode);
    }

    return rootNode;
  }

  /**
   * Evaluates statement declarations
   * @param ctx StatementCstChildren
   * @param parent Group
   */
  public statement(ctx: StatementCstChildren, parent: Group): void {
    if (ctx?.importFileStatement) {
      this.visit(ctx.importFileStatement, parent);
    } else if (ctx?.importStatement) {
      this.visit(ctx.importStatement, parent);
    } else if (ctx?.groupDeclaration) {
      this.visit(ctx.groupDeclaration, parent);
    } else {
      //? push errors to AST class?
      // throw new Error('Unhandled statement type');
    }
  }

  public importFileStatement(
    ctx: ImportFileStatementCstChildren,
    parent: CmdlTree
  ): void {
    let idToken: CmdlToken | undefined;
    let locationToken: CmdlToken | undefined;

    if (ctx.Identifier && ctx.Identifier.length) {
      idToken = this.extractToken(ctx.Identifier[0]);
    }

    if (ctx.StringLiteral && ctx.StringLiteral.length) {
      locationToken = this.extractToken(ctx.StringLiteral[0]);
    }

    if (idToken && locationToken) {
      const fileReference = new ImportFileOp(idToken, locationToken);
      parent.add(fileReference);
    }
  }

  /**
   * Evaluates import statements from CST
   * @param ctx ImportStatementCstChildren
   * @param parent CmdlTree
   */
  public importStatement(
    ctx: ImportStatementCstChildren,
    parent: CmdlTree
  ): void {
    let idToken: CmdlToken | undefined;
    let locationToken: CmdlToken | undefined;
    let aliasToken: CmdlToken | undefined;
    if (ctx.Identifier && ctx.Identifier.length) {
      idToken = this.extractToken(ctx.Identifier[0]);
    }

    if (ctx.alias && ctx.alias.length) {
      aliasToken = this.visit(ctx.alias);
    }

    if (ctx.StringLiteral && ctx.StringLiteral.length) {
      locationToken = this.extractToken(ctx.StringLiteral[0]);
    }

    if (idToken && locationToken) {
      const reference = new ImportOp(idToken, locationToken, aliasToken);
      parent.add(reference);
    }
  }

  aliasClause(ctx: AliasClauseCstChildren) {
    if (ctx.Identifier && ctx.Identifier.length) {
      return this.extractToken(ctx.Identifier[0]);
    }
  }

  groupDeclaration(ctx: GroupDeclarationCstChildren, parent: Group) {
    let group: Group;

    let token: CmdlToken;

    if (ctx.namedGroup && ctx.namedGroup.length) {
      const { nameToken, idToken } = this.visit(ctx.namedGroup);
      group = new NamedGroup(nameToken, idToken);
      parent.add(group);
    } else if (ctx?.Identifier && ctx.Identifier.length) {
      token = this.extractToken(ctx.Identifier[0]);
      group = new GeneralGroup(token);
      parent.add(group);
    } else if (ctx?.variableGroup && ctx.variableGroup.length) {
      const { nameToken, variableToken } = this.visit(ctx.variableGroup);
      group = new VariableGroup(nameToken, variableToken);
      parent.add(group);
    } else if (ctx?.referenceDeclaration && ctx.referenceDeclaration.length) {
      const { refToken, pathTokens } = this.visit(ctx.referenceDeclaration);
      group = new ReferenceGroup(refToken, pathTokens);
      parent.add(group);
    } else {
      //create error => missing group identifier
      throw new Error("unable to parse");
    }

    if (ctx?.group && ctx.group.length) {
      this.visit(ctx.group[0], group);
    }
  }

  namedGroup(ctx: NamedGroupCstChildren) {
    const idToken = this.extractToken(ctx.Identifier[0]);
    const nameToken = this.extractToken(ctx.Keyword[0]);

    return { idToken, nameToken };
  }

  variableGroup(ctx: VariableGroupCstChildren) {
    const variableToken = this.extractToken(ctx.Variable[0]);
    const nameToken = this.extractToken(ctx.Keyword[0]);

    return { variableToken, nameToken };
  }

  referenceDeclaration(ctx: ReferenceDeclarationCstChildren) {
    const refToken = this.extractToken(ctx.Link[0]);

    const pathTokens: CmdlToken[] = [];
    if (ctx?.Identifier && ctx.Identifier.length) {
      let token: CmdlToken;

      for (const subId of ctx.Identifier) {
        token = this.extractToken(subId);
        pathTokens.push(token);
      }
    }

    return { refToken, pathTokens };
  }

  group(ctx: GroupCstChildren, parent: Group) {
    if (ctx?.groupItem && ctx.groupItem.length) {
      for (const item of ctx.groupItem) {
        this.visit(item, parent);
      }
    }
  }

  groupItem(ctx: GroupItemCstChildren, parent: Group) {
    if (ctx?.groupDeclaration) {
      this.visit(ctx.groupDeclaration, parent);
    } else if (ctx?.propertyItem) {
      this.visit(ctx.propertyItem, parent);
    } else if (ctx?.arrowProperty) {
      this.visit(ctx.arrowProperty, parent);
    } else if (ctx?.assignmentProperty) {
      this.visit(ctx.assignmentProperty, parent);
    } else {
      // create error => bad group item
    }
  }

  assignmentProperty(ctx: AssignmentPropertyCstChildren, parent: Group) {
    if (ctx.Identifier && ctx.StringLiteral) {
      const identifier = this.extractToken(ctx.Identifier[0]);
      const value = this.extractToken(ctx.StringLiteral[0]);
      const assignmentProp = new AssignmentProperty(identifier, value);
      parent.add(assignmentProp);
    }
  }

  arrowProperty(ctx: ArrowPropertyCstChildren, parent: Group) {
    const lAngle = this.extractToken(ctx.LAngle[0]);
    const rAngle = this.extractToken(ctx.RAngle[0]);
    const angleProperty = new AngleProperty(lAngle, rAngle);
    parent.add(angleProperty);

    if (ctx.lhs && ctx.lhs.length) {
      angleProperty.setCurrentSide("lhs");
      this.visit(ctx.lhs, angleProperty);
    }

    if (ctx.rhs && ctx.rhs.length) {
      angleProperty.setCurrentSide("rhs");
      this.visit(ctx.rhs, angleProperty);
    }

    if (ctx.NumberLiteral && ctx.NumberLiteral.length) {
      const value = this.extractToken(ctx.NumberLiteral[0]);
      angleProperty.setValue(value);
    }
  }

  referencePipe(ctx: ReferencePipeCstChildren, parent: AngleProperty) {
    if (ctx.referenceDeclaration && ctx.referenceDeclaration.length) {
      for (const ref of ctx.referenceDeclaration) {
        const { refToken, pathTokens } = this.visit(ref);
        parent.addReference(refToken, pathTokens);
      }
    }
  }

  propertyItem(ctx: PropertyItemCstChildren, parent: Group) {
    let idToken: CmdlToken | null = null;
    if (ctx.Identifier.length) {
      idToken = this.extractToken(ctx.Identifier[0]);
    }

    if (ctx.value.length) {
      this.visit(ctx.value, { parent, idToken });
    }
  }

  value(
    ctx: ValueCstChildren,
    { parent, idToken }: { parent: Group; idToken: CmdlToken }
  ) {
    if (!idToken) {
      return;
    }

    let property:
      | NumericalProperty
      | BoolProperty
      | VariableProperty
      | RefProperty
      | StringProperty
      | ListProperty
      | RefListProperty
      | AngleProperty;

    let token: CmdlToken;

    if (ctx?.numericalValue) {
      property = new NumericalProperty(idToken);
      parent.add(property);
      this.visit(ctx.numericalValue, property);
    } else if (ctx?.list) {
      property = new ListProperty(idToken);
      parent.add(property);
      this.visit(ctx.list, property);
    } else if (ctx?.StringLiteral && ctx.StringLiteral.length) {
      token = this.extractToken(ctx.StringLiteral[0]);
      property = new StringProperty(idToken);
      property.setValue(token.image, token);
      parent.add(property);
    } else if (ctx?.referenceDeclaration) {
      property = new RefProperty(idToken);
      parent.add(property);
      const { refToken, pathTokens } = this.visit(ctx.referenceDeclaration);
      property.setValue(refToken);
      property.setPath(pathTokens);
    } else if (ctx?.True && ctx.True.length) {
      token = this.extractToken(ctx.True[0]);
      property = new BoolProperty(idToken);
      property.setValue(token.image, token);
      parent.add(property);
    } else if (ctx?.False && ctx.False.length) {
      token = this.extractToken(ctx.False[0]);
      property = new BoolProperty(idToken);
      property.setValue(token.image, token);
      parent.add(property);
    } else if (ctx?.Variable && ctx.Variable.length) {
      token = this.extractToken(ctx.Variable[0]);
      property = new VariableProperty(idToken);
      property.setValue(token.image, token);
      parent.add(property);
    } else if (ctx?.refList && ctx.refList.length) {
      property = new RefListProperty(idToken);
      parent.add(property);
      this.visit(ctx.refList, property);
    } else {
      //! push errors to AST class
    }
  }

  list(ctx: ListCstChildren, parent: ListProperty) {
    const tokens: CmdlToken[] = [];
    let token: CmdlToken;
    const values: string[] = [];
    for (const value of ctx.StringLiteral) {
      token = this.extractToken(value);
      tokens.push(token);
      values.push(token.image);
    }
    parent.setValue(values, tokens);
  }

  refList(ctx: RefListCstChildren, parent: RefListProperty) {
    if (ctx.referenceDeclaration && ctx.referenceDeclaration.length) {
      for (const ref of ctx.referenceDeclaration) {
        const { refToken, pathTokens } = this.visit(ref);
        parent.addReference(refToken, pathTokens);
      }
    }
  }

  numericalValue(ctx: NumericalValueCstChildren, parent: NumericalProperty) {
    let valueToken: CmdlToken;
    if (ctx?.value && ctx.value.length) {
      valueToken = this.extractToken(ctx.value[0]);
      parent.setValue(valueToken.image, valueToken);
    }

    if (ctx?.uncertainty && ctx.uncertainty.length) {
      this.visit(ctx.uncertainty, parent);
    }

    let unitToken: CmdlToken;
    if (ctx?.unit && ctx.unit.length) {
      unitToken = this.extractToken(ctx.unit[0]);
      parent.setUnit(unitToken.image, unitToken);
    }
  }

  uncertaintyExpression(
    ctx: UncertaintyExpressionCstChildren,
    parent: NumericalProperty
  ) {
    let token: CmdlToken;
    if (ctx?.NumberLiteral && ctx.NumberLiteral.length) {
      token = this.extractToken(ctx.NumberLiteral[0]);
      parent.setUncertainty(token.image, token);
    }
  }

  private extractToken(token: IToken): CmdlToken {
    return {
      image: token.image,
      type: token.tokenType.name,
      startLine: token.startLine,
      endLine: token.endLine,
      startOffset: token.startOffset,
      endOffset: token.endOffset,
    };
  }
}
